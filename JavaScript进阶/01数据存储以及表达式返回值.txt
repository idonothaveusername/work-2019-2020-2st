1、
20 20 20
12 13 20
过程：函数内部 var b = (c = a = 20); 从右向左进行赋值，最终可以得到a = 20，b = 20,c = 20。因此，第一次控制台返回的是20 20 20。
JavaScript中的函数fn(a)中改变的是形参a的值，又因为a是基本数据类型，因此形参a的值的变化并不能影响实参a的值，即a = 12；函数中的b为局部变量，不会影响函数外部b的值，因此b = 13；函数中的变量c为全局变量，它的值会覆盖原来c的值，因此c = 20。
2、
第一种方案可以改变字体的颜色；第二种方案不可以改变字体的颜色。
原因：box.style是一个对象，属于引用数据类型，var AA = box.style;是将box.style对象的地址赋给了AA，AA.color改变后box.style.color也会改变，因此第一种方案可以改变字体的颜色。box.style.color是一个字符串，属于基本数据类型，var BB = box.style.color;则是创建了一个新的变量使它的值为box.style.color，但是BB的值改变并不影响原来的box.style.color，因此第二种方案不能改变字体的颜色。
3、
（1）console.log(num && fn(obj) && num++);// 0 
（2）console.log(num);//  0
（3）console.log(obj.value);// 222 (字符串类型）
过程：（1）对 num && fn(obj) && num++ 表达式进行分析，从左到右进行运算，又可以显而易见的的值&&运算符左右两侧的操作数不是布尔型，根据&&的运算规则：转换后的左操作数若为 true，则直接返回原始右操作数，若为 false 则直接返回原始左操作数 进行运算。先计算表达式num && fn(obj) ：num = 1，转化为布尔类型为true，所以直接返回右操作数fn(obj);然后计算表达式 fn(obj) && num++ ：调用函数fn(obj)后，num = 0，obj.value = "222"(因为value的值是存放在堆内存当中的，所以值可以进行修改);同时函数的返回值为0，即fn(obj) = 0,转化为布尔类型为false，因此直接返回左操作数 0。
（2）num-- 为 num = num -1，此时的num为全局变量，会覆盖原来的num = 1.
（3）过程(1)中调用函数fn(obj)后，obj.value = "222"(因为value的值是存放在堆内存当中的，所以值可以进行修改)。


